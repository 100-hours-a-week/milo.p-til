## 📅 날짜: 2025-02-04

### 💬 스크럼
- 학습 목표 1 : numpy 강의정리 및 미니퀘스트 실습
- 학습 목표 2 : pandas 강의정리 및 미니퀘스트 실습
  
### 📒 공부한 내용
### 강의

### 개요

numpy

- 수치 계산 (배열 연산)
- 큰 배열을 빠르게 계산할 수 있도록 도와줌

pandas

- 데이터 분석 (통계)
- 데이터 조작과 분석을 위한 데이터프레임 시리즈

라이브러리 패키지 (남이 짠 코드)

pip : 패키지 관리자 (설치 명령어)

- 터미널에서 실행
- import는 파이썬 코드 안에서 실행

## Numpy

### numpy

numpy → 패키지

Numpy는 대규모 다차원 배열 및 행렬 연산을 위한 고성능 수학 함수와 도구를 제공하는 파이썬 라이브러리이다

```python
import numpy as np

# 간단한 배열 생성 및 출력
a = np.array([1, 2, 3, 4, 5])
print("NumPy array:", a)
```

---

### 차원

차원 : 어떤 대상의 숫자로 측정 가능한 속성, 즉 배열에서 데이터를 구성하는 축(axis)의 개수

1차원 배열 : 수의 나열이 한 줄로 되어있음

2차원 배열 : 가로, 세로 두 줄로 나열됨

3차원 배열 : 축 3개(높이까지) 로 나열됨

n차원 배열 : 축 n개로 나열됨

스칼라 : 0차원 배열 → 숫자 1개 자체

벡터 : 1차원 배열

행렬 : 2차원 배열

텐서 : 3차원 배열

numpy에서는 차원 확장(축 추가), 차원 축소(축 삭제, 특정 축 연산 등) 제공

numpy 차원 확인 → .ndim 속성 사용

```python
tensor = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(tensor.ndim)

# 3 출력
```

**중요 : 차원 변경법**

→ 차원 변환에 있어 크기는 유지되어야 함(배열 총 원소 개수)

→ 즉 담는 방식(차원) 만 변경하는 것

1. reshape()
    1. 배열 크기를 유지하며 차원 변경
    
    ```python
    array = np.array([1, 2, 3, 4, 5, 6])
    reshaped_array = array.reshape(2, 3)
    print(reshaped_array)
    print(reshaped_array.ndim)
    ```
    
    ```python
    [[1 2 3]
     [4 5 6]]
    2
    ```
    
2. newaxis
    1. 차원 추가
    
    ```python
    vector = np.array([1, 2, 3])
    expanded_vector = vector[:, np.newaxis]
    print(expanded_vector.ndim)  # 출력: 2
    ```
    
    ```python
    	
    	[[1]
    	 [2]
    	 [3]]
    	2
    ```
    

---

### 형태(shape)

- 튜플 형태로 나타냄
- 차원 : 축의 개수
- 각 차원 크기 : 각 축에 존재하는 요소 개수

```python
[  [    [1, 2], [3, 4]
  ],
  [    [5, 6], [7, 8]
  ]
]
```

- 차원 수: `3` (3차원 배열)
- 형태(Shape): `(2, 2, 2)` → 2개의 블록, 각 블록에 2개의 행, 각 행에 2개의 열

축 0 : 행(세로)

축 1 : 열(가로)

축 2 : 블록 개수

1. .shape → 형태 확인
2. reshape() → 형태 변경(원본 유지)
3. resize() → 형태 변경(원본을 변경)
    1. 패딩(0으로 채워 확장) 등 가능
4. .newaxis → 차원 확장
5. flatten() → 다차원 배열 1차원으로 변환(원본 유지)
6. ravel() → 다차원 배열 1차원 변환(참조 변환)
    1. 반환 배열 수정 시 원본 배열도 변경 가능
7. transpose() → 배열 축 전환(순서 변경)

```python
array = np.array([[1, 2, 3], [4, 5, 6]])
transposed_array = array.transpose()
print(transposed_array)
```

```python
[[1 4]
 [2 5]
 [3 6]]
```

---

### data type

numpy에서는 아주 다양한 data type이 있음

- 정수 : `int8, int16, int32, int64, uint8, uint16`
- 실수 : `float16, float32, float64`
- 등등

1. .dtype → 데이터 타입 확인
    1. .itemsize → 각 요소 바이트 크기 확인
    2. .nbytes → 배열 전체 메모리 사용량 확인
2. dtype 인수 → 특정 데이터 타입을 명시적으로 지정
3. astype() → 데이터 타입 변경
    1. 파라미터 예시 : np.float64

---

### 인덱싱

index → 색인(대표 숫자). 배열 내 특정 요소의 위치를 나타내는 숫자

indexing → index를 써서 실제 해당 값을 얻어내는 과정

인덱싱 종류

- 정수 : 개별 요소 접근
    - arr[0] ⇒ 첫번째 요소
    - arr[-1] ⇒ arr[len(arr) -1]
    - syntactic sugar
- 슬라이싱 : 특정 범위 요소 접근
    - arr[1:4] ⇒ 1,2,3 인덱스
    - 첫 인덱스는 포함, 끝 인덱스는 불포함
    - arr[::2] ⇒ 0,2,4…인덱스 선택
- boolean : 조건 만족하는 요소 접근

```python
data = np.array([5, 10, 15, 20, 25])

# 10보다 큰 요소만 선택
filtered = data[data > 10]
print(filtered)

# 짝수만 선택
even_numbers = data[data % 2 == 0]
print(even_numbers)
```

```python
[15 20 25]
[10 20]
```

- fancy : 리스트, 배열을 사용하여 요소 접근

```python
array = np.array([10, 20, 30, 40, 50])

# 특정 인덱스 선택
indices = [0, 2, 4]
selected = array[indices]
print(selected)  # 출력: [10 30 50]

# 2차원 배열에서 특정 행 선택
matrix = np.array([[1, 2], [3, 4], [5, 6]])
rows = [0, 2]
print(matrix[rows])  # 출력: [[1 2] [5 6]]
```

```python
[10 30 50]
[[1 2]
 [5 6]]
```

---

### 연산

1. 요소별 연산
    1. 각 요소끼리 짝을 지어 연산
    2. 크기가 달라도 broadcasting 규칙 적용해서 연산 수행
    3. 자동으로 확장되어 큰 배열과의 연산 수행
2. 비교 연산
    1. boolean값 반환
3. 통계 연산
    1. 평균, 중앙값, 최대 최소, 표준편차
4. 선형대수 연산
    1. .dot() → 행렬 곱 (내적)
    2. .linalg.inv() → 역행렬 계산
    3. .transpose() → 전치행렬 (행과 열 변환)
5. 브로드캐스팅 연산

```python
matrix = np.array([[1, 2, 3], [4, 5, 6]])
vector = np.array([1, 2, 3])

result = matrix + vector
print(result)
```

```python
[[ 2  4  6]
 [ 5  7  9]]
```

- padding과는 다름 (0으로 채워지는것이 아님)
1. 논리 연산
    1. and, or 등

---

### 유니버셜 함수

- 배열의 모든 요소에 동일한 연산을 적용할 수 있는 기능임
- 반복적으로 수행되는 벡터화된 연산 제공
- 단일 입력 및 다중 입력 지원

단일, 다중 예시

- np.sqrt(arr) → 배열 각 요소에 제곱근 수행
- np.add(arr1, arr2) → 두 배열의 요소별 덧셈 수행

유니버셜 함수 사용 이유

- 고속 연산 (C기반)
- 벡터화로 코드 간결화 (반복문 사용 안함)
- 메모리 효율성 (브로드캐스팅 기능 덕분)
- 데이터 분석 및 계산 최적화

1. 산술 연산 → 사칙연산, 거듭제곱 등
    1. 배열 곱이 아닌 요소별 곱 연산
2. 비교 연산 → boolean 값 반환
3. 논리 연산
4. 삼각 함수
5. 지수 및 로그 연산
6. 브로드캐스팅
    
    ```python
    array = np.array([1, 2, 3])
    scalar = 10
    
    print(np.add(array, scalar))
    ```
    
    ```python
    [11 12 13]
    ```
    
7. out 매개변수를 사용해 연산 결과 기존 배열에 저장
    
    ```python
    a = np.array([1, 2, 3])
    result = np.empty_like(a)
    # a와 shape만 같은 빈 배열
    
    np.multiply(a, 10, out=result)
    print(result)
    ```
    
    ```python
    [10 20 30]
    ```
    

---

## Pandas

### pandas

- 데이터 분석, 분류, 전처리 특화 라이브러리
- 데이터프레임 및 시리즈 객체를 제공하는 파이썬 라이브러리
- 기본적으로 테이블 구조(행렬) 분석
- numpy기반으로 빠른 연산 제공
- matplotlib, seaborn 등 라이브러리와 연동되어 시각적 표현

사용 이유

- 비정형 데이터를 구조화하여 분석 (데이터 가공)
- 방대한 양 데이터를 효율적으로 처리

피벗

→ 사업 아이템을 바꾸는 것 (스타트업 기준)

→ 데이터를 기준에 따라 재구성 (행,열 변환, 특정 열 새로운 차원 배치 등)

```python
# 간단한 데이터프레임 생성
data = {
    '이름': ['홍길동', '김철수', '이영희'],
    '나이': [25, 30, 35],
    '도시': ['서울', '부산', '인천']
}

df = pd.DataFrame(data)

# 데이터프레임 출력
print(df)
```

```python
    이름  나이  도시
0  홍길동  25  서울
1  김철수  30  부산
2  이영희  35  인천
```

---

### 시리즈(series)

시리즈(series) → 인덱스를 가지는 1차원 배열 형태의 데이터 구조

![https://www.dataairevolution.com/2024/06/exploring-data-with-pandas-series-and-dataframes/](attachment:814c3b16-986f-4a97-88dc-661ac5672256:image.png)

https://www.dataairevolution.com/2024/06/exploring-data-with-pandas-series-and-dataframes/

- dataFrame 의 재료임
- 고유한 인덱스를 통해 요소에 쉽게 접근
- 기본적으로 정수형 인덱스를 가지지만, 특정한 레이블(문자열, 날짜 등)로 지정할 수 있음 (인덱스 커스터마이징)
    
    ```python
    import pandas as pd
    
    # 리스트를 이용한 Series 생성
    series = pd.Series([10, 20, 30, 40], index=['a', 'b', 'c', 'd'])
    
    # 요소 접근
    print(series['a'])
    
    # 구분선
    print('---')
    
    # 벡터 연산 적용
    print(series * 2)
    ```
    
    ```python
    10
    ---
    a    20
    b    40
    c    60
    d    80
    dtype: int64
    ```
    

시리즈 객체 생성 방법

1. 리스트
2. 딕셔너리 (인덱스 key로 지정)
3. 리스트 + 인덱스
4. 데이터 타입 지정하여 생성

시리즈 기본 속성

```python
s = pd.Series([10, 20, 30, 40], index=['a', 'b', 'c', 'd'])

print(s.values)  # Series의 값 출력
print(s.index)   # 인덱스 확인
print(s.dtype)   # 데이터 타입 확인
print(s.shape)   # 크기 확인 (튜플 형식)
print(s.size)    # 요소 개수 확인
s.name = 'Example Series'  # Series의 이름 설정
print(s.name)    # Series의 이름 출력
```

```python
[10 20 30 40]
Index(['a', 'b', 'c', 'd'], dtype='object')
int64
(4,)
4
Example Series
```

결측값 (NaN, 즉 NULL값) 자동 처리

- isnull()함수 : 빈 값 (None) boolean으로 확인
- fillna()함수 : 결측치 채우기

---

### 데이터프레임 (DataFrame)

- series로 구성된 2차원 테이블 구조
- 값이 행(row) 단위로 입력, 키가 열(column) 이름으로 설정
- column을 가져오는 것이 기본임 (동일 데이터 타입)

- 기본 문법 및 사용법
    
    ### 기본 문법
    
    Pandas의 DataFrame은 다양한 방법으로 생성할 수 있으며, 데이터의 형태에 따라 적절한 방법을 선택하여 사용할 수 있습니다.
    
    1. **딕셔너리를 이용한 생성**
        
        딕셔너리를 사용하면 열(column) 이름과 값(value)을 정의하여 직관적인 방식으로 데이터프레임을 생성할 수 있습니다.
        
        ```python
        import pandas as pd
        import numpy as np
        
        data = {'이름': ['홍길동', '김철수', '박영희'],
                '나이': [25, 30, 28],
                '성별': ['남', '남', '여']}
        
        df = pd.DataFrame(data)
        print(df)
        ```
        
        - 출력 결과
            
            ```python
                이름  나이 성별
            0  홍길동  25  남
            1  김철수  30  남
            2  박영희  28  여
            ```
            
            - 딕셔너리의 키가 열(column) 이름으로 설정되고, 값들이 행(row) 단위로 입력됩니다.
            - 인덱스는 기본적으로 0부터 시작하는 정수형 인덱스가 자동으로 부여됩니다.
        
    2. **리스트를 이용한 생성**
        
        리스트를 사용하여 행 단위의 데이터를 입력하고, `columns` 매개변수를 통해 열 이름을 지정할 수 있습니다.
        
        ```python
        data = [[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]]
        
        df = pd.DataFrame(data, columns=['A', 'B', 'C'])
        print(df)
        ```
        
        - 출력 결과
            
            ```python
               A  B  C
            0  1  2  3
            1  4  5  6
            2  7  8  9
            ```
            
            - 리스트 내부의 각 서브리스트가 행(row)을 구성하며, 열(column) 이름은 `columns` 매개변수를 통해 설정합니다.
            - 데이터의 크기와 일치하는 열 이름을 지정해야 합니다.
        
    3. **NumPy 배열을 이용한 생성**
        
        NumPy 배열을 활용하면 대규모 수치 데이터를 효과적으로 처리할 수 있습니다.
        
        ```python
        data = np.array([[10, 20, 30],
                         [40, 50, 60]])
        
        df = pd.DataFrame(data, columns=['X', 'Y', 'Z'])
        print(df)
        ```
        
        - 실행 결과
            
            ```python
                X   Y   Z
            0  10  20  30
            1  40  50  60
            ```
            
            - NumPy 배열을 사용하면 수치 데이터의 연산 및 처리가 보다 빠르고 효율적으로 수행됩니다.
            - 배열의 크기와 일치하는 열 이름을 지정해야 합니다.
    
    ### 데이터프레임 기본 속성
    
    Pandas DataFrame은 다양한 속성을 제공하여 데이터의 구조와 내용을 쉽게 확인할 수 있습니다.
    
    ```python
    # 학생들의 성적 데이터 (10명)
    data = {'이름': ['홍길동', '김철수', '박영희', '이순신', '강감찬', '신사임당', '율곡이이', '정약용', '허준', '세종대왕'],
            '국어': [90, 85, 78, 92, 88, 95, 89, 91, 86, 93],
            '영어': [88, 92, 80, 90, 85, 93, 87, 90, 89, 91],
            '수학': [95, 87, 91, 94, 89, 92, 90, 93, 88, 94]}
    
    # 데이터프레임 생성
    df = pd.DataFrame(data)
    
    print(df.head())  # 처음 5개 행 출력
    print(df.tail())  # 마지막 5개 행 출력
    print(df.shape)   # 행과 열의 개수
    print(df.columns)  # 열 이름
    print(df.index)   # 행 인덱스
    print(df.info())  # 데이터프레임 요약 정보
    print(df.describe())  # 수치형 데이터의 요약 통계량
    ```
    
    - 출력 결과
        
        ```python
            이름  국어  영어  수학
        0  홍길동  90  88  95
        1  김철수  85  92  87
        2  박영희  78  80  91
        3  이순신  92  90  94
        4  강감찬  88  85  89
        
             이름  국어  영어  수학
        5  신사임당  95  93  92
        6  율곡이이  89  87  90
        7   정약용  91  90  93
        8    허준  86  89  88
        9  세종대왕  93  91  94
        
        (10, 4)
        
        Index(['이름', '국어', '영어', '수학'], dtype='object')
        
        RangeIndex(start=0, stop=10, step=1)
        
        <class 'pandas.core.frame.DataFrame'>
        RangeIndex: 10 entries, 0 to 9
        Data columns (total 4 columns):
         #   Column  Non-Null Count  Dtype 
        ---  ------  --------------  ----- 
         0   이름      10 non-null     object
         1   국어      10 non-null     int64 
         2   영어      10 non-null     int64 
         3   수학      10 non-null     int64 
        dtypes: int64(3), object(1)
        memory usage: 452.0+ bytes
        None
        
                      국어         영어         수학
        count  10.000000  10.000000  10.000000
        mean   88.700000  88.500000  91.300000
        std     4.854551   3.807887   2.750757
        min    78.000000  80.000000  87.000000
        25%    86.500000  87.250000  89.250000
        50%    89.500000  89.500000  91.500000
        75%    91.750000  90.750000  93.750000
        max    95.000000  93.000000  95.000000
        ```
        
        - `.head()`: 첫 5개 행을 출력하여 데이터의 개요를 빠르게 확인
        - `.tail()`: 마지막 5개 행을 출력하여 최신 데이터를 검토
        - `.shape`: 행과 열의 개수를 튜플 형태로 반환 (`(10, 4) → 10행 4열`)
        - `.columns`: 열의 이름 목록 반환
        - `.index`: 행 인덱스 범위 반환
        - `.info()`: 데이터의 타입, 결측치 여부 등을 요약
        - `.describe()`: 수치형 데이터를 요약하여 평균(mean), 표준편차(std), 최댓값(max) 등을 제공
    
    ### 데이터 접근
    
    DataFrame에서는 인덱스와 열 이름을 활용하여 특정 데이터를 쉽게 접근할 수 있습니다.
    
    ```python
    # 특정 열 선택
    print(df['이름'])
    print('\n')
    
    # 여러 열 선택
    print(df[['이름', '수학']])
    print('\n')
    
    # 특정 행 선택 (iloc: 정수 기반 인덱싱, loc: 레이블 기반 인덱싱)
    print(df.iloc[0])  # 첫 번째 행
    print(df.loc[0])  # 첫 번째 행 (레이블이 있는 경우)
    print('\n')
    
    # 특정 행과 열 선택
    print(df.loc[0, '이름'])
    ```
    
    - 출력 결과
        
        ```python
        0     홍길동
        1     김철수
        2     박영희
        3     이순신
        4     강감찬
        5    신사임당
        6    율곡이이
        7     정약용
        8      허준
        9    세종대왕
        Name: 이름, dtype: object
        
             이름  수학
        0   홍길동  95
        1   김철수  87
        2   박영희  91
        3   이순신  94
        4   강감찬  89
        5  신사임당  92
        6  율곡이이  90
        7   정약용  93
        8    허준  88
        9  세종대왕  94
        
        이름    홍길동
        국어     90
        영어     88
        수학     95
        Name: 0, dtype: object
        이름    홍길동
        국어     90
        영어     88
        수학     95
        Name: 0, dtype: object
        
        홍길동
        ```
        
        - `.iloc[]`: 행 번호 기반으로 데이터 선택.
        - `.loc[]`: 인덱스 레이블 기반으로 데이터 선택.
        - 단일 열 및 다중 열 선택 가능.
        - 특정 셀 값 선택 시 `df.loc[row_index, column_name]` 형식을 사용.
    
    ### **데이터 수정 및 연산**
    
    데이터프레임의 데이터를 수정하고 새로운 데이터를 추가할 수 있습니다.
    
    1. **특정 값 수정**
        
        홍길동의 국어 점수를 92점으로 변경합니다.
        
        ```python
        df.loc[0, '국어'] = 92
        print(df.iloc[0])
        ```
        
        - 출력 결과
            
            ```python
            이름    홍길동
            국어     92
            영어     88
            수학     95
            Name: 0, dtype: object
            ```
            
        
    2. **새로운 열 추가**
        
        모든 학생의 국적을 '한국'으로 추가합니다.
        
        ```python
        df['국적'] = '한국'
        print(df)
        ```
        
        - 출력 결과
            
            ```python
                 이름  국어  영어  수학  국적
            0   홍길동  92  88  95  한국
            1   김철수  85  92  87  한국
            2   박영희  78  80  91  한국
            3   이순신  92  90  94  한국
            4   강감찬  88  85  89  한국
            5  신사임당  95  93  92  한국
            6  율곡이이  89  87  90  한국
            7   정약용  91  90  93  한국
            8    허준  86  89  88  한국
            9  세종대왕  93  91  94  한국
            ```
            
        
    3. **기존 열 삭제**
        
        '국적' 열을 삭제합니다.
        
        ```python
        df.drop('국적', axis=1, inplace=True)
        print(df)
        ```
        
        - 출력 결과
            
            ```python
                 이름  국어  영어  수학
            0   홍길동  92  88  95
            1   김철수  85  92  87
            2   박영희  78  80  91
            3   이순신  92  90  94
            4   강감찬  88  85  89
            5  신사임당  95  93  92
            6  율곡이이  89  87  90
            7   정약용  91  90  93
            8    허준  86  89  88
            9  세종대왕  93  91  94
            ```
            
        
    4. **새로운 열 생성 (기존 열 연산)**
        
        총점 열을 추가합니다.
        
        ```python
        df['총점'] = df['국어'] + df['영어'] + df['수학']
        print(df)
        ```
        
        - 출력 결과
            
            ```python
                 이름  국어  영어  수학   총점
            0   홍길동  92   88   95  275
            1   김철수  85  92  87  264
            2   박영희  78  80  91  249
            3   이순신  92  90  94  276
            4   강감찬  88  85  89  262
            5  신사임당  95  93  92  280
            6  율곡이이  89  87  90  266
            7   정약용  91  90  93  274
            8    허준  86  89  88  263
            9  세종대왕  93  91  94  278
            ```
            
        
    5. **조건에 따른 데이터 추출**
        
        국어 점수가 90점 이상인 학생만 추출합니다.
        
        ```python
        high_korean = df[df['국어'] >= 90]
        print(high_korean)
        ```
        
        - 출력 결과
            
            ```python
                 이름  국어  영어  수학   총점
            0   홍길동  92  88  95  275
            3   이순신  92  90  94  276
            5  신사임당  95  93  92  280
            7   정약용  91  90  93  274
            9  세종대왕  93  91  94  278
            ```
            
    
    ### **데이터 정렬**
    
    1. **특정 열 기준 오름차순 정렬**
        
        수학 점수 기준으로 오름차순으로 정렬해 출력합니다.
        
        ```python
        df_sorted_math = df.sort_values(by='수학')
        print(df_sorted_math)
        ```
        
        - 출력 결과
            
            ```python
                 이름  국어  영어  수학   총점
            1   김철수  85  92  87  264
            8    허준  86  89  88  263
            4   강감찬  88  85  89  262
            6  율곡이이  89  87  90  266
            2   박영희  78  80  91  249
            5  신사임당  95  93  92  280
            7   정약용  91  90  93  274
            3   이순신  92  90  94  276
            9  세종대왕  93  91  94  278
            0   홍길동  92  88  95  275
            ```
            
        
    2. **특정 열 기준 내림차순 정렬**
        
        이름 기준으로 내림차순으로 정렬해 출력합니다.
        
        ```python
        df_sorted_name = df.sort_values(by='이름', ascending=False)
        print(df_sorted_name)
        ```
        
        - 출력 결과
            
            ```python
                 이름  국어  영어  수학   총점
            0   홍길동  92  88  95  275
            8    허준  86  89  88  263
            7   정약용  91  90  93  274
            3   이순신  92  90  94  276
            6  율곡이이  89  87  90  266
            5  신사임당  95  93  92  280
            9  세종대왕  93  91  94  278
            2   박영희  78  80  91  249
            1   김철수  85  92  87  264
            4   강감찬  88  85  89  262
            ```
            
    
    ### **데이터 그룹화**
    
     성별 열을 추가한 뒤 성별 데이터로 다음과 같이 그룹화할 수 있습니다.
    
    ```python
    df['성별'] = ['남', '남', '여', '남', '남', '여', '남', '남', '남', '남']
    gender_mean = df.groupby('성별')['국어'].mean()
    print(gender_mean)
    ```
    
    - 출력 결과
        
        ```python
        성별
        남    89.5
        여    86.5
        Name: 국어, dtype: float64
        ```
        
    
    ### **결측치 처리**
    
    결측치가 없다고 가정하고 진행합니다.
    
    만약 결측치가 있다면 다음과 같이 처리할 수 있습니다.
    
    ```python
    # 학생들의 성적 데이터 재생성
    data = {'이름': ['홍길동', '김철수', '박영희', '이순신', '강감찬', '신사임당', '율곡이이', '정약용', '허준', '세종대왕'],
            '국어': [90, 85, 78, 92, 88, 95, 89, 91, 86, 93],
            '영어': [88, 92, 80, 90, 85, 93, 87, 90, 89, 91],
            '수학': [95, 87, 91, 94, 89, 92, 90, 93, 88, 94]}
    
    df = pd.DataFrame(data)
    
    # 가상의 결측치 생성 (예시)
    df.loc[2, '영어'] = np.nan
    
    # 결측치 확인
    print(df.isnull().sum())
    print('\n')
    
    # 결측치 제거
    df.dropna(inplace=True)
    
    # 결측치 확인
    print(df.isnull().sum())
    
    # 결측치를 0으로 채우기
    # df.fillna(0, inplace=True)
    ```
    
    - 출력 결과
        
        ```python
        이름    0
        국어    0
        영어    1
        수학    0
        dtype: int64
        
        이름    0
        국어    0
        영어    0
        수학    0
        dtype: int64
        ```
        
    
    ### **데이터 저장 및 로딩**
    
    데이터를 CSV 파일로 저장하고 불러올 수 있습니다.
    
    ```python
    # CSV 파일로 저장
    df.to_csv('student_scores.csv', index=False)
    
    # CSV 파일로 읽기 (새로운 데이터프레임에 저장)
    new_df = pd.read_csv('student_scores.csv')
    print(new_df)
    ```
    
    - 출력 결과
        
        ```python
             이름  국어    영어  수학
        0   홍길동  90  88.0  95
        1   김철수  85  92.0  87
        2   이순신  92  90.0  94
        3   강감찬  88  85.0  89
        4  신사임당  95  93.0  92
        5  율곡이이  89  87.0  90
        6   정약용  91  90.0  93
        7    허준  86  89.0  88
        8  세종대왕  93  91.0  94
        ```
        
        ![image.png](attachment:9bd6a7f2-5f22-4eb0-9858-d594140a8ad2:image.png)
        

---

### 필터링

- 원하는 값 추출
- 조건을 만족하는 데이터 추출 가능

1. boolean indexing → df[조건] 형태로 필터링 수행
2. 다중 조건 필터링 → 논리 연산자 사용
3. query() 사용 → SQL 유사한 스타일로 필터링 (문자열 표현식 필터링)
4. isin() 사용 → 여러 값 중 하나라도 포함되어 있는지 여부 확인
5. str.contains() → 특정 문자열이 포함된 데이터 필터링
6. apply() → 람다 식 조건에 따라 새로운 열 추가
    
    ```python
    # 점수가 90 이상인 경우 '합격', 그렇지 않으면 '불합격' 추가
    df['합격여부'] = df['점수'].apply(lambda x: '합격' if x >= 90 else '불합격')
    print(df)
    ```
    
    ```python
        이름  나이  도시  점수 합격여부
    0  홍길동  25  서울  85  불합격
    1  김철수  30  부산  90   합격
    2  박영희  35  서울  75  불합격
    3  이순신  40  대구  95   합격
    4  강감찬  45  부산  80  불합격
    ```
    
7. 결측치 필터링

### 기본 문법

Pandas에서 필터링을 수행하려면 **조건식을 사용하여 원하는 데이터를 선택**할 수 있습니다.

기본적으로 `df[조건]` 형태로 작성하며, 조건식을 통해 특정 열의 값을 기준으로 데이터를 필터링할 수 있습니다.

```python
import pandas as pd

# 데이터프레임 생성
data = {'이름': ['홍길동', '김철수', '박영희', '이순신', '강감찬'],
        '나이': [25, 30, 35, 40, 45],
        '도시': ['서울', '부산', '서울', '대구', '부산'],
        '점수': [85, 90, 75, 95, 80]}

df = pd.DataFrame(data)

# 특정 조건 필터링 예제
filtered_df = df[df['나이'] > 30]
print(filtered_df)
```

- 출력 결과:
    
    ```python
        이름  나이   도시  점수
    2  박영희  35   서울  75
    3  이순신  40   대구  95
    4  강감찬  45   부산  80
    ```
    

### 필터링 방법

Pandas에서 필터링을 수행하는 여러 가지 방법이 있습니다.

- **불리언 인덱싱을 사용한 필터링**
    
    불리언 배열을 사용하여 특정 조건을 만족하는 데이터만 선택할 수 있습니다.
    
    `df[조건]` 형태로 필터링을 수행하며, 특정 컬럼의 값이 주어진 조건을 만족하는 경우 해당 행이 선택됩니다.
    
    ```python
    # 나이가 30 이상인 행 필터링
    print(df[df['나이'] >= 30])
    print('\n')
    
    # 점수가 85점 이상인 행 필터링
    print(df[df['점수'] >= 85])
    ```
    
    - 출력 결과
        
        ```python
            이름  나이  도시  점수
        1  김철수  30  부산  90
        2  박영희  35  서울  75
        3  이순신  40  대구  95
        4  강감찬  45  부산  80
        
            이름  나이  도시  점수
        0  홍길동  25  서울  85
        1  김철수  30  부산  90
        3  이순신  40  대구  95
        ```
        
        - 첫 번째 결과에서는 `나이 >= 30` 조건을 만족하는 행만 필터링되었습니다.
        - 두 번째 결과에서는 `점수 >= 85` 조건을 만족하는 데이터만 추출되었습니다.
    
- **논리 연산자를 사용한 다중 조건 필터링**
    
    논리 연산자인 `&`(AND), `|`(OR), `~`(NOT) 연산자를 조합하여 복합 조건을 적용할 수 있습니다.
    
    여러 조건을 조합할 때는 괄호를 사용하여 우선순위를 지정해야 합니다.
    
    ```python
    # 나이가 30 이상이고 점수가 80점 초과인 데이터 필터링
    print(df[(df['나이'] >= 30) & (df['점수'] > 80)])
    print('\n')
    
    # 도시가 '서울'이거나 점수가 90 이상인 데이터 필터링
    print(df[(df['도시'] == '서울') | (df['점수'] >= 90)])
    print('\n')
    
    # 나이가 40 이하가 아닌 데이터 필터링 (NOT 연산)
    print(df[~(df['나이'] <= 40)])
    ```
    
    - 출력 결과
        
        ```python
            이름  나이  도시  점수
        1  김철수  30  부산  90
        3  이순신  40  대구  95
        
            이름  나이  도시  점수
        0  홍길동  25  서울  85
        1  김철수  30  부산  90
        2  박영희  35  서울  75
        3  이순신  40  대구  95
        
            이름  나이  도시  점수
        4  강감찬  45  부산  80
        ```
        
        - `&` 연산자로 나이가 30 이상이고 점수가 80 초과인 데이터를 필터링
        - `|` 연산자로 도시가 "서울"이거나 점수가 90 이상인 데이터를 선택
        - `~` 연산자를 사용하여 나이가 40 이하가 아닌 행을 선택
    
- **`query()`를 사용한 필터링**
    
    SQL과 유사한 스타일로 데이터를 필터링하는 방식입니다.
    
    문자열 표현식을 통해 필터링이 가능하며 가독성이 높은 편입니다.
    
    ```python
    # 점수가 85보다 높은 데이터 필터링
    print(df.query('점수 > 85'))
    print('\n')
    
    # 나이가 30 이상이고 도시가 '부산'인 데이터 필터링
    print(df.query('나이 >= 30 and 도시 == "부산"'))
    ```
    
    - 출력 결과
        
        ```python
            이름  나이  도시  점수
        1  김철수  30  부산  90
        3  이순신  40  대구  95
        
            이름  나이  도시  점수
        1  김철수  30  부산  90
        4  강감찬  45  부산  80
        ```
        
        - 첫 번째 예제에서는 `점수 > 85` 조건을 만족하는 데이터 필터링
        - 두 번째 예제에서는 `나이 >= 30 and 도시 == "부산"` 조건을 만족하는 데이터 선택
    
- **`isin()`을 사용한 필터링**
    
    여러 값 중 하나라도 포함되어 있는지 여부를 확인할 때 `isin()` 메서드를 사용합니다.
    
    ```python
    # 도시가 '서울' 또는 '부산'인 데이터 필터링
    print(df[df['도시'].isin(['서울', '부산'])])
    print('\n')
    
    # 특정 이름만 포함하는 데이터 필터링
    print(df[df['이름'].isin(['김철수', '이순신'])])
    ```
    
    - 출력 결과
        
        ```python
            이름  나이  도시  점수
        0  홍길동  25  서울  85
        1  김철수  30  부산  90
        2  박영희  35  서울  75
        4  강감찬  45  부산  80
        
            이름  나이  도시  점수
        1  김철수  30  부산  90
        3  이순신  40  대구  95
        ```
        
        - `isin()`을 사용하여 특정 도시나 이름이 포함된 행을 필터링
    
- **문자열 필터링 (`str.contains()` 활용)**
    
    `str.contains()`를 사용하여 특정 문자열이 포함된 데이터를 필터링할 수 있습니다.
    
    ```python
    # 이름에 '김'이 포함된 행 필터링
    print(df[df['이름'].str.contains('김')])
    print('\n')
    
    # 도시 이름이 '부'로 시작하는 데이터 필터링
    print(df[df['도시'].str.startswith('부')])
    ```
    
    - 출력 결과
        
        ```python
            이름  나이  도시  점수
        1  김철수  30  부산  90
        
            이름  나이  도시  점수
        1  김철수  30  부산  90
        4  강감찬  45  부산  80
        ```
        
        - `str.contains()`를 사용하여 특정 문자열이 포함된 데이터를 필터링
        - `str.startswith()`를 사용하여 특정 문자로 시작하는 데이터를 필터링
    
- **조건에 따른 새로운 열 추가**
    
    `apply()`를 사용하여 조건에 따라 새로운 열을 추가할 수 있습니다.
    
    ```python
    # 점수가 90 이상인 경우 '합격', 그렇지 않으면 '불합격' 추가
    df['합격여부'] = df['점수'].apply(lambda x: '합격' if x >= 90 else '불합격')
    print(df)
    ```
    
    - 출력 결과
        
        ```python
            이름  나이  도시  점수 합격여부
        0  홍길동  25  서울  85  불합격
        1  김철수  30  부산  90   합격
        2  박영희  35  서울  75  불합격
        3  이순신  40  대구  95   합격
        4  강감찬  45  부산  80  불합격
        ```
        
        - 점수가 90 이상인 경우 "합격", 그렇지 않으면 "불합격" 값을 추가
    
- **결측치(NaN) 필터링**
    
    결측치가 포함된 데이터를 찾거나 제거할 때 필터링을 적용할 수 있습니다.
    
    ```python
    # 결측치가 있는 데이터 찾기
    print(df[df['점수'].isnull()])
    print('\n')
    
    # 결측치가 없는 데이터만 선택
    print(df[df['점수'].notnull()])
    ```
    
    - 출력 결과
        
        ```python
        Empty DataFrame
        Columns: [이름, 나이, 도시, 점수, 합격여부]
        Index: []
        
            이름  나이  도시  점수 합격여부
        0  홍길동  25  서울  85  불합격
        1  김철수  30  부산  90   합격
        2  박영희  35  서울  75  불합격
        3  이순신  40  대구  95   합격
        4  강감찬  45  부산  80  불합격
        ```
        

### 필터링 결과 저장 및 활용

필터링한 결과를 새로운 데이터프레임으로 저장하여 후속 분석에 활용할 수 있습니다.

```python
filtered_df = df[df['점수'] > 80]
filtered_df.to_csv('filtered_data.csv', index=False)
```

- 출력 결과
    
    ![image.png](attachment:0c949f80-4a31-40f9-a574-1c2dcf606f2f:image.png)
    

---

### 그룹화

- 데이터를 특정 기준에 따라 그룹화
- 체계적으로 분류하여 통계를 도출하기 위해 사용
- groupby() 메서드를 사용하여 수행

### 기본 문법

Pandas의 그룹화는 `groupby()` 메서드를 사용하여 특정 열을 기준으로 데이터를 그룹화한 후, 다양한 연산을 적용할 수 있습니다.

```python
import pandas as pd

# 예제 데이터 생성
data = {
    '이름': ['홍길동', '김철수', '박영희', '이순신', '강감찬', '신사임당'],
    '부서': ['영업', '영업', '인사', '인사', 'IT', 'IT'],
    '급여': [5000, 5500, 4800, 5100, 6000, 6200]
}

df = pd.DataFrame(data)

# 부서별 급여 평균 계산
grouped = df.groupby('부서')['급여'].mean()
print(grouped)
```

- 출력 결과
    
    ```python
    부서
    IT    6100.0
    영업    5250.0
    인사    4950.0
    Name: 급여, dtype: float64
    ```
    

### 단일 열을 기준으로 그룹화

특정 열을 기준으로 그룹화한 후 집계 연산을 수행할 수 있습니다.

```python
grouped = df.groupby('부서')['급여'].sum()
print(grouped)
```

- 출력 결과
    
    ```python
    부서
    IT    12200
    인사    9900
    영업   10500
    Name: 급여, dtype: int64
    ```
    
    - `df.groupby('부서')`: `df` 데이터프레임에서 `'부서'` 열을 기준으로 데이터를 그룹화합니다. 같은 부서에 속한 행들이 하나의 그룹으로 묶입니다.
    - `['급여'].sum()`: 그룹화된 각각의 부서에 대해 `'급여'` 열의 값을 합산합니다. 즉, 같은 부서의 급여 값들을 더한 결과를 반환합니다.

### 여러 열을 기준으로 그룹화

두 개 이상의 열을 기준으로 그룹화하여 분석할 수 있습니다.

```python
grouped = df.groupby(['부서', '이름'])['급여'].sum()
print(grouped)
```

- 출력 결과
    
    ```python
    부서  이름  
    IT  강감찬     6000
        신사임당    6200
    영업  김철수     5500
        홍길동     5000
    인사  박영희     4800
        이순신     5100
    Name: 급여, dtype: int64
    ```
    
    - `df.groupby(['부서', '이름'])`: 데이터프레임 `df`에서 `'부서'`와 `'이름'` 두 개의 열을 기준으로 데이터를 그룹화합니다.
        - 그룹화 결과는 다중 인덱스(MultiIndex)를 가지며, 같은 부서와 같은 이름을 가진 행들이 하나의 그룹으로 묶입니다.
    - `['급여'].sum()`: 그룹별 `'급여'` 값을 합산합니다. 같은 부서 내에서 동일한 이름을 가진 사람의 급여를 합산하여 반환합니다.
    
    <aside>
    ❓
    
    다중 인덱스(MultiIndex)가 뭐예요?
    
    </aside>
    
    <aside>
    👨‍💻
    
    다중 인덱스(MultiIndex)는 Pandas에서 하나의 축(행 또는 열)에 두 개 이상의 인덱스를 설정할 수 있는 기능입니다.
    
    예를 들어, `df.groupby(['부서', '이름'])`을 사용하면 부서와 이름이 계층적으로 설정된 인덱스로 그룹화됩니다.
    
    다중 인덱스를 사용하면 복잡한 데이터를 효율적으로 관리하고 조회할 수 있습니다.
    
    </aside>
    

### 그룹별 여러 개의 집계 연산 적용

여러 개의 집계 연산을 동시에 적용할 수 있습니다.

```python
grouped = df.groupby('부서')['급여'].agg(['sum', 'mean', 'max', 'min'])
print(grouped)
```

- 출력 결과
    
    ```python
          sum    mean   max   min
    부서                           
    IT  12200  6100.0  6200  6000
    영업  10500  5250.0  5500  5000
    인사   9900  4950.0  5100  4800
    ```
    
    - `df.groupby('부서')`: `'부서'` 열을 기준으로 데이터를 그룹화합니다.
    - `['급여'].agg(['sum', 'mean', 'max', 'min'])`: `.agg()` 메서드를 사용하여 한 번에 여러 집계 함수를 적용합니다.
        - `sum`: 각 그룹의 급여 합계
        - `mean`: 각 그룹의 평균 급여
        - `max`: 각 그룹에서 가장 높은 급여
        - `min`: 각 그룹에서 가장 낮은 급여

### 그룹화 후 필터링

특정 조건을 만족하는 그룹만 선택할 수 있습니다.

```python
# 급여 합계가 10000 이상인 그룹만 선택
filtered = df.groupby('부서').filter(lambda x: x['급여'].sum() > 10000)
print(filtered)
```

- 출력 결과
    
    ```python
         이름  부서    급여
    0   홍길동  영업  5000
    1   김철수  영업  5500
    4   강감찬  IT  6000
    5  신사임당  IT  6200
    ```
    
    - `df.groupby('부서')`: `'부서'` 열을 기준으로 데이터를 그룹화합니다.
    - `.filter(lambda x: x['급여'].sum() > 10000)`: 각 그룹별로 급여 합계가 10000을 초과하는 경우만 필터링하여 유지합니다. 결과적으로 `영업`과 `IT` 부서만 남게 됩니다.

### 그룹별 변환 (Transformation)

그룹화된 데이터에서 각 행을 그룹의 기준값으로 변환할 수 있습니다.

```python
df['급여_평균'] = df.groupby('부서')['급여'].transform('mean')
print(df)
```

- 출력 결과
    
    ```python
         이름  부서    급여   급여_평균
    0   홍길동  영업  5000  5250.0
    1   김철수  영업  5500  5250.0
    2   박영희  인사  4800  4950.0
    3   이순신  인사  5100  4950.0
    4   강감찬  IT  6000  6100.0
    5  신사임당  IT  6200  6100.0
    ```
    
    - `df.groupby('부서')['급여'].transform('mean')`: 각 부서별 급여 평균을 계산하고, 해당 부서의 모든 행에 적용합니다. 원래 데이터프레임의 크기를 유지하면서 평균 급여 값을 추가합니다.

### 그룹별 사용자 정의 함수 적용

그룹별로 사용자 정의 함수를 적용하여 복잡한 분석이 가능합니다.

```python
def categorize_salary(x):
    return '고임금' if x.mean() > 5000 else '저임금'

df['급여_카테고리'] = df.groupby('부서')['급여'].transform(categorize_salary)
print(df)
```

- 출력 결과:
    
    ```python
         이름  부서    급여   급여_평균 급여_카테고리
    0   홍길동  영업  5000  5250.0     고임금
    1   김철수  영업  5500  5250.0     고임금
    2   박영희  인사  4800  4950.0     저임금
    3   이순신  인사  5100  4950.0     저임금
    4   강감찬  IT  6000  6100.0     고임금
    5  신사임당  IT  6200  6100.0     고임금
    ```
    
    - `categorize_salary(x)`: 그룹의 평균 급여가 5000 이상이면 '고임금', 그렇지 않으면 '저임금'을 반환하는 함수.
    - `.transform(categorize_salary)`: 해당 그룹의 평균 급여를 기준으로 전체 데이터를 변환하여 `'급여_카테고리'` 열을 추가합니다.

### 그룹별 순위 계산

그룹 내에서 데이터를 순위별로 정렬할 수 있습니다.

```python
df['급여_순위'] = df.groupby('부서')['급여'].rank(ascending=False)
print(df)
```

- 출력 결과
    
    ```python
         이름  부서    급여   급여_평균 급여_카테고리  급여_순위
    0   홍길동  영업  5000  5250.0     고임금    2.0
    1   김철수  영업  5500  5250.0     고임금    1.0
    2   박영희  인사  4800  4950.0     저임금    2.0
    3   이순신  인사  5100  4950.0     저임금    1.0
    4   강감찬  IT  6000  6100.0     고임금    2.0
    5  신사임당  IT  6200  6100.0     고임금    1.0
    ```
    
    - `df.groupby('부서')['급여'].rank(ascending=False)`: 각 부서 내에서 급여를 내림차순 정렬 후 순위를 매깁니다. 높은 급여가 1순위가 되도록 설정됩니다.

---

### Merging

- 여러 데이터프레임을 공통 열 또는 인덱스를 기준으로 결함

병합 종류

- Inner join : 공통된 키 값을 기준으로 병합. 일치하는 값만 포함
- Outer join : 모든 데이터 유지, 일치하지 않는 값은 NaN으로 표시
- Left join : 첫 번째 데이터프레임의 모든 데이터 유지
- Right join : 두 번째 데이터프레임의 모든 데이터 유지
    
    ![https://datacomy.com/data_analysis/pandas/merge/](attachment:4b5507c8-62f1-4add-bb59-c0432a7f7535:image.png)
    
    https://datacomy.com/data_analysis/pandas/merge/
    

### 기본 문법

Pandas의 `merge()` 메서드를 사용하여 데이터프레임을 병합할 수 있습니다.

```python
import pandas as pd

# 기본 문법
pd.merge(left, right, how='병합 방식', on='기준 열')
```

- **`left`**, **`right`**: 병합할 두 개의 데이터프레임을 지정합니다.
- **`how`**: 병합 방식으로 다음 옵션이 있습니다.
    - `'inner'`: 공통된 키 값만 유지
    - `'outer'`: 모든 데이터를 유지하며, 일치하지 않는 값은 `NaN`으로 처리
    - `'left'`: 왼쪽 데이터프레임 기준으로 병합
    - `'right'`: 오른쪽 데이터프레임 기준으로 병합
- **`on`**: 병합할 기준이 되는 공통 열(키)을 지정합니다. 여러 개의 열을 기준으로 할 경우 리스트 형태로 제공할 수 있습니다.

### 1. 내부 조인 (Inner Join)

공통된 키 값이 있는 행만 병합하여 반환합니다.

```python
import pandas as pd

df1 = pd.DataFrame({'고객ID': [1, 2, 3],
                    '이름': ['홍길동', '김철수', '이영희']})

df2 = pd.DataFrame({'고객ID': [2, 3, 4],
                    '구매액': [10000, 20000, 30000]})

result = pd.merge(df1, df2, on='고객ID', how='inner')
print(result)
```

- 출력 결과
    
    ```python
       고객ID   이름    구매액
    0     2  김철수  10000
    1     3  이영희  20000
    ```
    
    - `on='고객ID'`: 두 데이터프레임에서 공통 열인 `'고객ID'`를 기준으로 병합합니다.
    - `how='inner'`: 공통된 `고객ID` 값이 있는 행만 남기고, 나머지는 제거합니다.
    

### 2. 외부 조인 (Outer Join)

모든 데이터를 병합하며, 일치하지 않는 값은 `NaN`으로 처리합니다.

```python
result = pd.merge(df1, df2, on='고객ID', how='outer')
print(result)
```

- 출력 결과
    
    ```python
       고객ID   이름      구매액
    0     1  홍길동      NaN
    1     2  김철수  10000.0
    2     3  이영희  20000.0
    3     4  NaN  30000.0
    ```
    
    - `how='outer'`: 모든 데이터를 포함하여 병합하고, 일치하지 않는 값은 `NaN`으로 채웁니다.

### 3. 왼쪽 조인 (Left Join)

왼쪽 데이터프레임의 모든 데이터를 유지하고, 일치하는 값만 병합합니다.

```python
result = pd.merge(df1, df2, on='고객ID', how='left')
print(result)
```

- 출력 결과
    
    ```python
       고객ID   이름      구매액
    0     1  홍길동      NaN
    1     2  김철수  10000.0
    2     3  이영희  20000.0
    ```
    
    - `how='left'`: 왼쪽 데이터프레임(`df1`)의 모든 행을 유지하고, 오른쪽 데이터프레임(`df2`)에서 일치하는 데이터를 병합합니다.
        - 일치하지 않는 경우, 오른쪽에서 가져올 값이 없는 경우 `NaN`으로 표시합니다.

### 4. 오른쪽 조인 (Right Join)

오른쪽 데이터프레임의 모든 데이터를 유지하고, 일치하는 값만 병합합니다.

```python
result = pd.merge(df1, df2, on='고객ID', how='right')
print(result)
```

- 출력 결과
    
    ```python
       고객ID   이름    구매액
    0     2  김철수  10000
    1     3  이영희  20000
    2     4  NaN  30000
    ```
    
    - `how='right'`: 오른쪽 데이터프레임(`df2`)의 모든 행을 유지하고, 왼쪽 데이터프레임(`df1`)에서 일치하는 데이터를 병합합니다.
        - 왼쪽에 없는 값은 `NaN`으로 채워집니다.

### 5. 여러 열을 기준으로 병합

두 개 이상의 열을 기준으로 병합할 수 있습니다.

```python
df1 = pd.DataFrame({'고객ID': [1, 2, 3],
                    '이름': ['홍길동', '김철수', '이영희'],
                    '도시': ['서울', '부산', '대전']})

df2 = pd.DataFrame({'고객ID': [2, 3, 4],
                    '도시': ['부산', '대전', '광주'],
                    '구매액': [10000, 20000, 30000]})

result = pd.merge(df1, df2, on=['고객ID', '도시'], how='inner')
print(result)
```

- 출력 결과
    
    ```python
       고객ID   이름  도시    구매액
    0     2  김철수  부산  10000
    1     3  이영희  대전  20000
    ```
    
    - 두 개 이상의 열을 기준으로 병합하여 동일한 `고객ID`와 `도시`가 모두 일치하는 경우에만 데이터를 병합합니다.

### 6. 인덱스를 기준으로 병합

인덱스를 기준으로 병합하려면 `left_index=True` 또는 `right_index=True` 옵션을 사용합니다.

```python
df1 = pd.DataFrame({'이름': ['홍길동', '김철수', '박영희']}, index=[1, 2, 3])
df2 = pd.DataFrame({'구매액': [15000, 25000, 30000]}, index=[1, 3, 4])

result = pd.merge(df1, df2, left_index=True, right_index=True, how='outer')
print(result)
```

- 출력 결과
    
    ```python
        이름      구매액
    1  홍길동  15000.0
    2  김철수      NaN
    3  박영희  25000.0
    4  NaN  30000.0
    ```
    
    - `left_index=True`, `right_index=True`: 행 인덱스를 기준으로 데이터를 병합합니다.
    - `how='outer'`: 모든 인덱스를 유지하고 일치하지 않는 값은 `NaN`으로 채워집니다.

### 7. 병합 후 열 이름 변경

병합된 결과에서 열 이름이 충돌하는 경우, 접미사(suffix)를 사용하여 구분할 수 있습니다.

```python
df1 = pd.DataFrame({'고객ID': [1, 2], '이름': ['홍길동', '김철수'], '구매액': [20000, 30000]})
df2 = pd.DataFrame({'고객ID': [1, 2], '이름': ['박영희', '이순신'], '구매액': [40000, 50000]})

result = pd.merge(df1, df2, on='고객ID', suffixes=('_기존', '_신규'))
print(result)
```

- 출력 결과
    
    ```python
       고객ID 이름_기존  구매액_기존 이름_신규  구매액_신규
    0     1   홍길동   20000   박영희   40000
    1     2   김철수   30000   이순신   50000
    ```
    
    - `on='고객ID'`: `'고객ID'` 열을 기준으로 병합합니다.
    - `suffixes=('_기존', '_신규')`: 두 데이터프레임에 존재하는 동일한 열 이름(예: `'이름'`, `'구매액'`)을 `_기존`과 `_신규`로 구분하여 처리합니다.
    - 병합된 결과에서 `이름`과 `구매액` 열이 `이름_기존`, `이름_신규`와 같이 새로운 열 이름으로 생성됩니다.

### 8. 병합을 활용한 조건 기반 분석

특정 조건을 만족하는 데이터만 병합하고 필터링할 수 있습니다.

```python
filtered_result = pd.merge(df1, df2, on='고객ID', how='inner', suffixes=('_기존', '_신규'))
filtered_result = filtered_result[filtered_result['구매액_기존'] > 25000]
print(filtered_result)
```

- 출력 결과
    
    ```python
       고객ID 이름_기존  구매액_기존 이름_신규  구매액_신규
    1     2   김철수   30000   이순신   50000
    ```
    
    - `pd.merge(df1, df2, on='고객ID', how='inner', suffixes=('_기존', '_신규'))`: `고객ID`를 기준으로 내부 조인을 수행합니다.
        - 결과적으로 두 데이터프레임에서 `고객ID` 1, 2가 병합된 상태가 됩니다.
    - `filtered_result[filtered_result['구매액_기존'] > 25000]`:`'구매액_기존'` 열의 값이 25000보다 큰 행만 필터링하여 출력합니다.

### 데이터프레임 연결 (`concat`) vs 병합 (`merge`)

Pandas의 `concat()` 함수는 데이터를 단순히 연결(위/아래 또는 좌/우)하는 반면, `merge()`는 공통된 열을 기준으로 데이터를 결합합니다.

```python
df_concat = pd.concat([df1, df2], ignore_index=True)
print(df_concat)
```

- 출력 결과
    
    ```python
       고객ID   이름    구매액
    0     1  홍길동  20000
    1     2  김철수  30000
    2     1  박영희  40000
    3     2  이순신  50000
    ```
    
    - `pd.concat([df1, df2], ignore_index=True)`: 두 데이터프레임을 **행 방향**으로 연결합니다. `ignore_index=True` 옵션을 사용하여 기존 인덱스를 무시하고 새 인덱스를 생성합니다.
    

**병합(`merge`) vs 연결(`concat`) 차이점**

| 구분 | 차이점 |
| --- | --- |
| **`merge()`** | 공통 열(키)을 기준으로 병합 수행. 일치하는 데이터를 병합하고 일치하지 않으면 `NaN`이 발생 |
| **`concat()`** | 단순한 연결이며, 병합할 키 없이 데이터를 합치는 데 사용 |

---

### 결측치 처리 (Missing Data)

- NaN 데이터 탐지, 제거, 대체하는 작업
- 전처리에서 핵심적인 작업, 데이터 품질 향상
- `isnull()`, `dropna()`, `fillna()` 등의 함수를 사용하여 데이터를 탐지, 삭제, 또는 특정 값으로 대체

1. 결측치 확인 → isnull() 등으로 확인, True면 결측치 존재
2. 결측치 제거 → dropna()로 결측치 제거
3. 결측지 대체 → fillna()
    
    ```python
    # 예제 데이터프레임 재생성
    data = {'이름': ['홍길동', '김철수', np.nan, '이영희'],
            '나이': [25, np.nan, 30, 28],
            '성별': ['남', '남', '여', np.nan]}
    
    df = pd.DataFrame(data)
    
    # 특정 값으로 대체
    df_filled_value = df.fillna(value={'이름': '없음', '나이': '없음', '성별': '없음'})
    print("특정 값으로 대체:")
    print(df_filled_value)
    print('\n')
    
    # 평균값으로 대체
    df['나이'] = df['나이'].fillna(df['나이'].mean())
    print("평균값으로 대체:")
    print(df)
    print('\n')
    
    # 이전 값으로 대체
    df_filled_forward = df.ffill()
    print("이전 값으로 대체 (ffill):")
    print(df_filled_forward)
    print('\n')
    
    # 이후 값으로 대체
    df_filled_backward = df.bfill()
    print("이후 값으로 대체 (bfill):")
    print(df_filled_backward)
    ```
    
    ```python
    특정 값으로 대체:
        이름    나이  성별
    0  홍길동  25.0   남
    1  김철수    없음   남
    2   없음  30.0   여
    3  이영희  28.0  없음
    
    평균값으로 대체:
        이름         나이   성별
    0  홍길동  25.000000    남
    1  김철수  27.666667    남
    2  NaN  30.000000    여
    3  이영희  28.000000  NaN
    
    이전 값으로 대체 (ffill):
        이름         나이 성별
    0  홍길동  25.000000  남
    1  김철수  27.666667  남
    2  김철수  30.000000  여
    3  이영희  28.000000  여
    
    이후 값으로 대체 (bfill):
        이름         나이   성별
    0  홍길동  25.000000    남
    1  김철수  27.666667    남
    2  이영희  30.000000    여
    3  이영희  28.000000  NaN
    ```
    
4. 결측치 행 필터링 → isnull, notnull 등

---

### Pivot

- 데이터를 시각적으로 직관적인 형태로 재구성하는 과정
- 행, 열을 재배치하여 가독성 높이고 쉽게 분석하기 위해 사용

Pivot vs Pivot table

- pivot → 고유한 키 조합에 사용 가능, 중복되면 오류
- pivot table → 중복되어도 사용 가능, 통계처리 가능 (다기능)

### 기본 문법

Pandas의 `pivot()` 메서드를 사용하면 데이터프레임을 특정 열을 기준으로 **재구성**할 수 있습니다.

```python
import pandas as pd

# 기본 문법
df.pivot(index='행으로 설정할 열', columns='열로 설정할 열', values='값으로 설정할 열')
```

- **`index`**: 행으로 사용할 열을 지정합니다. (예: 날짜, 카테고리 등)
- **`columns`**: 열로 사용할 열을 지정합니다. (예: 제품, 지역 등)
- **`values`**: 값으로 사용할 열을 지정합니다. (예: 판매량, 이익 등)

### 1. 단순 피벗

하나의 기준으로 데이터를 재구성하여 분석할 수 있습니다.

```python
import pandas as pd

# 샘플 데이터 생성
data = {
    '날짜': ['2024-01-01', '2024-01-01', '2024-01-02', '2024-01-02'],
    '제품': ['A', 'B', 'A', 'B'],
    '판매량': [100, 200, 150, 250]
}

df = pd.DataFrame(data)

# 피벗 적용
df_pivot = df.pivot(index='날짜', columns='제품', values='판매량')
print(df_pivot)
```

- 출력 결과
    
    ```python
    제품            A    B
    날짜                  
    2024-01-01  100  200
    2024-01-02  150  250
    ```
    
    - `날짜` 열을 행(index)으로 설정
    - `제품` 열을 열(columns)로 설정
    - `판매량`을 값(values)으로 설정
    - 날짜 행과 제품 열 개수가 둘다 4개 → 2개로 줄었음

### 2. 여러 열을 피벗하기 (다중 인덱싱)

하나 이상의 열을 기준으로 데이터 구조를 변경할 수 있습니다.

멀티 인덱스 사용

```python
data = {
    '날짜': ['2024-01-01', '2024-01-01', '2024-01-02', '2024-01-02'],
    '카테고리': ['전자', '가전', '전자', '가전'],
    '제품': ['A', 'B', 'A', 'B'],
    '판매량': [100, 200, 150, 250]
}

df = pd.DataFrame(data)

# 피벗 적용 (날짜 및 카테고리 기준)
df_pivot = df.pivot(index=['날짜', '카테고리'], columns='제품', values='판매량')
print(df_pivot)
```

- 출력 결과
    
    ```python
    제품                   A      B
    날짜         카테고리              
    2024-01-01 가전      NaN  200.0
               전자    100.0    NaN
    2024-01-02 가전      NaN  250.0
               전자    150.0    NaN
    ```
    
    - `날짜`와 `카테고리`를 행으로 설정
    - `제품`을 열로 설정
    - `판매량`을 값으로 설정

### 3. 결측치 처리

`pivot()`을 사용하면 중복된 데이터가 있을 경우 오류가 발생하므로, `pivot_table()`을 대신 사용할 수 있습니다.

```python
df_pivot_table = df.pivot_table(index='날짜', columns='제품', values='판매량', aggfunc='sum', fill_value=0)
print(df_pivot_table)
```

- 출력 결과
    
    ```python
    제품            A    B
    날짜                  
    2024-01-01  100  200
    2024-01-02  150  250
    ```
    
    - `aggfunc='sum'`을 사용하여 중복된 데이터를 합산
    - `fill_value=0`으로 결측치를 0으로 채움

### 4. 여러 값 피벗하기

한 번의 피벗에서 여러 개의 값을 포함할 수 있습니다.

```python
data = {
    '날짜': ['2024-01-01', '2024-01-01', '2024-01-02', '2024-01-02'],
    '제품': ['A', 'B', 'A', 'B'],
    '판매량': [100, 200, 150, 250],
    '이익': [20, 50, 30, 60]
}

df = pd.DataFrame(data)

# 피벗 적용
df_pivot = df.pivot(index='날짜', columns='제품', values=['판매량', '이익'])
print(df_pivot)
```

- 출력 결과
    
    ```python
                판매량       이익    
    제품            A    B   A   B
    날짜                          
    2024-01-01  100  200  20  50
    2024-01-02  150  250  30  60
    ```
    
    - `판매량`과 `이익`을 동시에 피벗

### 5. 특정 함수 적용 (aggfunc)

`pivot_table()`을 사용하면 다양한 요약 통계를 적용할 수 있습니다.

```python
df_pivot_table = df.pivot_table(index='날짜', columns='제품', values='판매량', aggfunc=['sum', 'mean'])
print(df_pivot_table)
```

- 출력 결과
    
    ```python
                sum        mean       
    제품            A    B      A      B
    날짜                                
    2024-01-01  100  200  100.0  200.0
    2024-01-02  150  250  150.0  250.0
    ```
    
    - `sum`과 `mean` 함수를 적용하여 데이터를 요약.

### 6. 피벗 결과 저장 및 로드

피벗된 데이터를 CSV로 저장하거나 로드할 수 있습니다.

```python
df_pivot.to_csv('pivot_result.csv')
df_loaded = pd.read_csv('pivot_result.csv', index_col=0)
print(df_loaded)
```

- 출력 결과
    
    ```python
                판매량 판매량.1   이익 이익.1
    제품            A     B    A    B
    날짜          NaN   NaN  NaN  NaN
    2024-01-01  100   200   20   50
    2024-01-02  150   250   30   60
    ```
    
    ![image.png](attachment:93ec76d4-9b8f-4e26-acf0-c77fd234de1a:image.png)
    

<aside>
❓

`pivot()`과 `pivot_table()`의 차이점이 뭐예요?

</aside>

<aside>
👨‍💻

`pivot()`은 중복된 데이터가 없는 경우에만 사용 가능하며, 단순히 데이터를 재구성하는 데 초점을 맞춥니다.

`pivot_table()`은 중복된 데이터를 처리할 수 있으며, 집계 함수(`sum`, `mean` 등)를 적용하여 데이터를 요약할 수 있습니다.

`pivot()`에서는 결측치 처리 기능이 없지만, `pivot_table()`에서는 `fill_value`를 사용해 결측값을 채울 수 있습니다.

`pivot()`은 데이터 변형만 수행하고, `pivot_table()`은 데이터를 요약 및 집계할 수 있습니다.

요약하면, `pivot_table()`은 더 유연하며 복잡한 데이터 처리가 가능하므로 실무에서 더 자주 사용됩니다.

</aside>

---

### 중복 제거 (Duplicates Removal)

- 데이터프레임, 시리즈에서 중복 행 식별 및 제거
- drop_duplicates() 를 사용하여 중복 행 제거
    - 특정 열 기준으로 중복 제거 가능
    - 중복 행에서 특정 값 유지 가능

---

### 문자열 처리

| 메서드 | 설명 | 예제 |
| --- | --- | --- |
| `str.lower()` | 문자열을 소문자로 변환 | `df['컬럼'].str.lower()` |
| `str.upper()` | 문자열을 대문자로 변환 | `df['컬럼'].str.upper()` |
| `str.strip()` | 앞뒤 공백 제거 | `df['컬럼'].str.strip()` |
| `str.replace()` | 특정 문자열을 다른 값으로 대체 | `df['컬럼'].str.replace('a', 'b')` |
| `str.contains()` | 특정 문자열 포함 여부 확인 | `df['컬럼'].str.contains('패턴')` |
| `str.startswith()` | 특정 문자열로 시작하는지 여부 확인 | `df['컬럼'].str.startswith('문자')` |
| `str.endswith()` | 특정 문자열로 끝나는지 여부 확인 | `df['컬럼'].str.endswith('문자')` |
| `str.split()` | 특정 구분자로 문자열 나누기 | `df['컬럼'].str.split('-')` |
| `str.len()` | 문자열 길이 반환 | `df['컬럼'].str.len()` |
| `str.findall()` | 정규 표현식 패턴과 일치하는 부분 검색 | `df['컬럼'].str.findall(r'\d+')` |

---

### 한 줄 정리

| Numpy | 다차원 배열의 빠른 연산을 위한 고성능 수학 라이브러리 |
| --- | --- |
| dimension(차원) | 배열에서 데이터를 구성하는 축(axis)의 개수, 0차원(스칼라), 1차원(벡터), 2차원(행렬), 3차원 이상(텐서)로 표현됨 |
| shape(형태) | 배열의 깊이, 행, 열 등의 구조를 나타내는 튜플 |
| index | 배열 내 특정 요소의 위치를 나타내는 대표 숫자 |
| universal func | numpy에서 배열의 모든 요소에 동일한 연산을 적용할 수 있는 함수 |
| Pandas | 테이블 구조의 데이터 분석, 분류, 전처리에 특화된 파이썬 라이브러리 |
| series | 인덱스와 값을 가지는 1차원 배열 형태의 데이터 구조 |
| dataframe | 여러 개의 시리즈로 구성된 2차원 테이블 데이터 구조 |
| grouping | 특정 기준에 따라 데이터를 그룹화하는 것. 체계적으로 분류하여 통계 도출에 사용 |
| merging | 여러 데이터프레임을 공통된 열 혹은 인덱스를 기준으로 병합 |
| pivot | 행과 열의 재배치 과정을 통해 데이터를 시각적으로 직관적인 형태로 재구성하는 과정 |

---




### 💭 오늘의 회고
- 성공적인 점 : 피곤했지만 집중해서 잘 수강했다.
- 개선해야 할 점 : 잠을 더 자야햘 것 같다..
  
### 📁 참고 자료 및 링크
- 
